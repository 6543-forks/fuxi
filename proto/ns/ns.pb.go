// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/ns/ns.proto

/*
	Package go_micro_srv_ns is a generated protocol buffer package.

	It is generated from these files:
		proto/ns/ns.proto

	It has these top-level messages:
		NS
		NSResponse
		Empty
		NamespaceListResponse
		NamespaceName
*/
package go_micro_srv_ns

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NS struct {
	Monitors             string `protobuf:"bytes,1,opt,name=monitors,proto3" json:"monitors,omitempty"`
	AdminSecretName      string `protobuf:"bytes,2,opt,name=adminSecretName,proto3" json:"adminSecretName,omitempty"`
	Pool                 string `protobuf:"bytes,3,opt,name=pool,proto3" json:"pool,omitempty"`
	UserId               string `protobuf:"bytes,4,opt,name=userId,proto3" json:"userId,omitempty"`
	UserSecretName       string `protobuf:"bytes,5,opt,name=userSecretName,proto3" json:"userSecretName,omitempty"`
	Namespace            string `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
	AdminId              string `protobuf:"bytes,7,opt,name=adminId,proto3" json:"adminId,omitempty"`
	Isdefault            bool   `protobuf:"varint,8,opt,name=isdefault,proto3" json:"isdefault,omitempty"`
	Cidrblock            string `protobuf:"bytes,9,opt,name=cidrblock,proto3" json:"cidrblock,omitempty"`
	Namespacesexcludeips string `protobuf:"bytes,10,opt,name=namespacesexcludeips,proto3" json:"namespacesexcludeips,omitempty"`
	Namespaces           string `protobuf:"bytes,11,opt,name=namespaces,proto3" json:"namespaces,omitempty"`
	Namespacename        string `protobuf:"bytes,12,opt,name=namespacename,proto3" json:"namespacename,omitempty"`
	Cpu                  string `protobuf:"bytes,13,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory               string `protobuf:"bytes,14,opt,name=memory,proto3" json:"memory,omitempty"`
	Storage              string `protobuf:"bytes,15,opt,name=storage,proto3" json:"storage,omitempty"`
	Cputhreshold         int32  `protobuf:"varint,16,opt,name=cputhreshold,proto3" json:"cputhreshold,omitempty"`
	Memorythreshold      int32  `protobuf:"varint,17,opt,name=memorythreshold,proto3" json:"memorythreshold,omitempty"`
	Storagethreshold     int32  `protobuf:"varint,18,opt,name=storagethreshold,proto3" json:"storagethreshold,omitempty"`
	Isdelete             bool   `protobuf:"varint,19,opt,name=isdelete,proto3" json:"isdelete,omitempty"`
	Creator              string `protobuf:"bytes,20,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *NS) Reset()                    { *m = NS{} }
func (m *NS) String() string            { return proto.CompactTextString(m) }
func (*NS) ProtoMessage()               {}
func (*NS) Descriptor() ([]byte, []int) { return fileDescriptorNs, []int{0} }

func (m *NS) GetMonitors() string {
	if m != nil {
		return m.Monitors
	}
	return ""
}

func (m *NS) GetAdminSecretName() string {
	if m != nil {
		return m.AdminSecretName
	}
	return ""
}

func (m *NS) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *NS) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *NS) GetUserSecretName() string {
	if m != nil {
		return m.UserSecretName
	}
	return ""
}

func (m *NS) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NS) GetAdminId() string {
	if m != nil {
		return m.AdminId
	}
	return ""
}

func (m *NS) GetIsdefault() bool {
	if m != nil {
		return m.Isdefault
	}
	return false
}

func (m *NS) GetCidrblock() string {
	if m != nil {
		return m.Cidrblock
	}
	return ""
}

func (m *NS) GetNamespacesexcludeips() string {
	if m != nil {
		return m.Namespacesexcludeips
	}
	return ""
}

func (m *NS) GetNamespaces() string {
	if m != nil {
		return m.Namespaces
	}
	return ""
}

func (m *NS) GetNamespacename() string {
	if m != nil {
		return m.Namespacename
	}
	return ""
}

func (m *NS) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *NS) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *NS) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *NS) GetCputhreshold() int32 {
	if m != nil {
		return m.Cputhreshold
	}
	return 0
}

func (m *NS) GetMemorythreshold() int32 {
	if m != nil {
		return m.Memorythreshold
	}
	return 0
}

func (m *NS) GetStoragethreshold() int32 {
	if m != nil {
		return m.Storagethreshold
	}
	return 0
}

func (m *NS) GetIsdelete() bool {
	if m != nil {
		return m.Isdelete
	}
	return false
}

func (m *NS) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

type NSResponse struct {
}

func (m *NSResponse) Reset()                    { *m = NSResponse{} }
func (m *NSResponse) String() string            { return proto.CompactTextString(m) }
func (*NSResponse) ProtoMessage()               {}
func (*NSResponse) Descriptor() ([]byte, []int) { return fileDescriptorNs, []int{1} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorNs, []int{2} }

type NamespaceListResponse struct {
	Namespaces []*NS `protobuf:"bytes,1,rep,name=namespaces" json:"namespaces,omitempty"`
}

func (m *NamespaceListResponse) Reset()                    { *m = NamespaceListResponse{} }
func (m *NamespaceListResponse) String() string            { return proto.CompactTextString(m) }
func (*NamespaceListResponse) ProtoMessage()               {}
func (*NamespaceListResponse) Descriptor() ([]byte, []int) { return fileDescriptorNs, []int{3} }

func (m *NamespaceListResponse) GetNamespaces() []*NS {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

type NamespaceName struct {
	Namespacename string `protobuf:"bytes,1,opt,name=namespacename,proto3" json:"namespacename,omitempty"`
}

func (m *NamespaceName) Reset()                    { *m = NamespaceName{} }
func (m *NamespaceName) String() string            { return proto.CompactTextString(m) }
func (*NamespaceName) ProtoMessage()               {}
func (*NamespaceName) Descriptor() ([]byte, []int) { return fileDescriptorNs, []int{4} }

func (m *NamespaceName) GetNamespacename() string {
	if m != nil {
		return m.Namespacename
	}
	return ""
}

func init() {
	proto.RegisterType((*NS)(nil), "go.micro.srv.ns.NS")
	proto.RegisterType((*NSResponse)(nil), "go.micro.srv.ns.NSResponse")
	proto.RegisterType((*Empty)(nil), "go.micro.srv.ns.Empty")
	proto.RegisterType((*NamespaceListResponse)(nil), "go.micro.srv.ns.NamespaceListResponse")
	proto.RegisterType((*NamespaceName)(nil), "go.micro.srv.ns.NamespaceName")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Ns service

type NsClient interface {
	CreateNameSpace(ctx context.Context, in *NS, opts ...grpc.CallOption) (*NSResponse, error)
	NamespaceList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NamespaceListResponse, error)
	DeleteNamespace(ctx context.Context, in *NamespaceName, opts ...grpc.CallOption) (*Empty, error)
	EditNamespace(ctx context.Context, in *NS, opts ...grpc.CallOption) (*Empty, error)
}

type nsClient struct {
	cc *grpc.ClientConn
}

func NewNsClient(cc *grpc.ClientConn) NsClient {
	return &nsClient{cc}
}

func (c *nsClient) CreateNameSpace(ctx context.Context, in *NS, opts ...grpc.CallOption) (*NSResponse, error) {
	out := new(NSResponse)
	err := grpc.Invoke(ctx, "/go.micro.srv.ns.Ns/CreateNameSpace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsClient) NamespaceList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NamespaceListResponse, error) {
	out := new(NamespaceListResponse)
	err := grpc.Invoke(ctx, "/go.micro.srv.ns.Ns/NamespaceList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsClient) DeleteNamespace(ctx context.Context, in *NamespaceName, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/go.micro.srv.ns.Ns/DeleteNamespace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsClient) EditNamespace(ctx context.Context, in *NS, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/go.micro.srv.ns.Ns/EditNamespace", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ns service

type NsServer interface {
	CreateNameSpace(context.Context, *NS) (*NSResponse, error)
	NamespaceList(context.Context, *Empty) (*NamespaceListResponse, error)
	DeleteNamespace(context.Context, *NamespaceName) (*Empty, error)
	EditNamespace(context.Context, *NS) (*Empty, error)
}

func RegisterNsServer(s *grpc.Server, srv NsServer) {
	s.RegisterService(&_Ns_serviceDesc, srv)
}

func _Ns_CreateNameSpace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NS)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).CreateNameSpace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/go.micro.srv.ns.Ns/CreateNameSpace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).CreateNameSpace(ctx, req.(*NS))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ns_NamespaceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).NamespaceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/go.micro.srv.ns.Ns/NamespaceList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).NamespaceList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ns_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/go.micro.srv.ns.Ns/DeleteNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).DeleteNamespace(ctx, req.(*NamespaceName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ns_EditNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NS)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).EditNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/go.micro.srv.ns.Ns/EditNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).EditNamespace(ctx, req.(*NS))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ns_serviceDesc = grpc.ServiceDesc{
	ServiceName: "go.micro.srv.ns.Ns",
	HandlerType: (*NsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNameSpace",
			Handler:    _Ns_CreateNameSpace_Handler,
		},
		{
			MethodName: "NamespaceList",
			Handler:    _Ns_NamespaceList_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Ns_DeleteNamespace_Handler,
		},
		{
			MethodName: "EditNamespace",
			Handler:    _Ns_EditNamespace_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/ns/ns.proto",
}

func (m *NS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Monitors) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Monitors)))
		i += copy(dAtA[i:], m.Monitors)
	}
	if len(m.AdminSecretName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.AdminSecretName)))
		i += copy(dAtA[i:], m.AdminSecretName)
	}
	if len(m.Pool) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Pool)))
		i += copy(dAtA[i:], m.Pool)
	}
	if len(m.UserId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.UserSecretName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.UserSecretName)))
		i += copy(dAtA[i:], m.UserSecretName)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.AdminId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.AdminId)))
		i += copy(dAtA[i:], m.AdminId)
	}
	if m.Isdefault {
		dAtA[i] = 0x40
		i++
		if m.Isdefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Cidrblock) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Cidrblock)))
		i += copy(dAtA[i:], m.Cidrblock)
	}
	if len(m.Namespacesexcludeips) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Namespacesexcludeips)))
		i += copy(dAtA[i:], m.Namespacesexcludeips)
	}
	if len(m.Namespaces) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Namespaces)))
		i += copy(dAtA[i:], m.Namespaces)
	}
	if len(m.Namespacename) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Namespacename)))
		i += copy(dAtA[i:], m.Namespacename)
	}
	if len(m.Cpu) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if len(m.Storage) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Storage)))
		i += copy(dAtA[i:], m.Storage)
	}
	if m.Cputhreshold != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNs(dAtA, i, uint64(m.Cputhreshold))
	}
	if m.Memorythreshold != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNs(dAtA, i, uint64(m.Memorythreshold))
	}
	if m.Storagethreshold != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNs(dAtA, i, uint64(m.Storagethreshold))
	}
	if m.Isdelete {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Isdelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Creator) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Creator)))
		i += copy(dAtA[i:], m.Creator)
	}
	return i, nil
}

func (m *NSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NSResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NamespaceListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, msg := range m.Namespaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NamespaceName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespacename) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNs(dAtA, i, uint64(len(m.Namespacename)))
		i += copy(dAtA[i:], m.Namespacename)
	}
	return i, nil
}

func encodeFixed64Ns(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ns(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NS) Size() (n int) {
	var l int
	_ = l
	l = len(m.Monitors)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.AdminSecretName)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.UserSecretName)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.AdminId)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	if m.Isdefault {
		n += 2
	}
	l = len(m.Cidrblock)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Namespacesexcludeips)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Namespaces)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Namespacename)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	if m.Cputhreshold != 0 {
		n += 2 + sovNs(uint64(m.Cputhreshold))
	}
	if m.Memorythreshold != 0 {
		n += 2 + sovNs(uint64(m.Memorythreshold))
	}
	if m.Storagethreshold != 0 {
		n += 2 + sovNs(uint64(m.Storagethreshold))
	}
	if m.Isdelete {
		n += 3
	}
	l = len(m.Creator)
	if l > 0 {
		n += 2 + l + sovNs(uint64(l))
	}
	return n
}

func (m *NSResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NamespaceListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovNs(uint64(l))
		}
	}
	return n
}

func (m *NamespaceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespacename)
	if l > 0 {
		n += 1 + l + sovNs(uint64(l))
	}
	return n
}

func sovNs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNs(x uint64) (n int) {
	return sovNs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monitors = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminSecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminSecretName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserSecretName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isdefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isdefault = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cidrblock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cidrblock = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespacesexcludeips", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespacesexcludeips = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespacename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespacename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cputhreshold", wireType)
			}
			m.Cputhreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cputhreshold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memorythreshold", wireType)
			}
			m.Memorythreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memorythreshold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storagethreshold", wireType)
			}
			m.Storagethreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Storagethreshold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isdelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isdelete = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, &NS{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespacename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespacename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/ns/ns.proto", fileDescriptorNs) }

var fileDescriptorNs = []byte{
	// 522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0x93, 0xe6, 0x6f, 0x9a, 0x34, 0xe9, 0xb4, 0x54, 0xab, 0x80, 0xa2, 0xc8, 0x42, 0x55,
	0xc4, 0xc1, 0x95, 0x52, 0x71, 0xe5, 0x00, 0xe4, 0x50, 0x51, 0x59, 0x22, 0x7e, 0x02, 0xd7, 0x5e,
	0x5a, 0x0b, 0xdb, 0x6b, 0xed, 0xae, 0x11, 0xbd, 0xf1, 0x3e, 0xbc, 0x08, 0x47, 0x1e, 0x01, 0xe5,
	0x49, 0xd0, 0x8e, 0x13, 0x3b, 0x3f, 0xce, 0x6d, 0xbe, 0x6f, 0xbe, 0x19, 0xcf, 0x7c, 0x3b, 0x32,
	0x5c, 0x64, 0x52, 0x68, 0x71, 0x9b, 0xaa, 0xdb, 0x54, 0x39, 0x14, 0xe3, 0xf0, 0x49, 0x38, 0x49,
	0x14, 0x48, 0xe1, 0x28, 0xf9, 0xc3, 0x49, 0x95, 0xfd, 0xab, 0x05, 0x0d, 0xd7, 0xc3, 0x31, 0x74,
	0x13, 0x91, 0x46, 0x5a, 0x48, 0xc5, 0xac, 0xa9, 0x35, 0xeb, 0x2d, 0x4b, 0x8c, 0x33, 0x18, 0xfa,
	0x61, 0x12, 0xa5, 0x1e, 0x0f, 0x24, 0xd7, 0xae, 0x9f, 0x70, 0xd6, 0x20, 0xc9, 0x3e, 0x8d, 0x08,
	0xa7, 0x99, 0x10, 0x31, 0x6b, 0x52, 0x9a, 0x62, 0xbc, 0x86, 0x76, 0xae, 0xb8, 0xbc, 0x0f, 0xd9,
	0x29, 0xb1, 0x6b, 0x84, 0x37, 0x70, 0x6e, 0xa2, 0xad, 0xa6, 0x2d, 0xca, 0xef, 0xb1, 0xf8, 0x06,
	0x7a, 0xa9, 0x9f, 0x70, 0x95, 0xf9, 0x01, 0x67, 0x6d, 0x92, 0x54, 0x04, 0x32, 0xe8, 0xd0, 0x10,
	0xf7, 0x21, 0xeb, 0x50, 0x6e, 0x03, 0x4d, 0x5d, 0xa4, 0x42, 0xfe, 0xcd, 0xcf, 0x63, 0xcd, 0xba,
	0x53, 0x6b, 0xd6, 0x5d, 0x56, 0x84, 0xc9, 0x06, 0x51, 0x28, 0x1f, 0x63, 0x11, 0x7c, 0x67, 0xbd,
	0xa2, 0x6b, 0x49, 0xe0, 0x1c, 0xae, 0xca, 0x4f, 0x28, 0xfe, 0x33, 0x88, 0xf3, 0x90, 0x47, 0x99,
	0x62, 0x40, 0xc2, 0xda, 0x1c, 0x4e, 0x00, 0x2a, 0x9e, 0x9d, 0x91, 0x72, 0x8b, 0xc1, 0xb7, 0x30,
	0x28, 0x91, 0x09, 0x58, 0x9f, 0x24, 0xbb, 0x24, 0x8e, 0xa0, 0x19, 0x64, 0x39, 0x1b, 0x50, 0xce,
	0x84, 0xc6, 0xbf, 0x84, 0x27, 0x42, 0xbe, 0xb0, 0xf3, 0xc2, 0xbf, 0x02, 0x99, 0xcd, 0x95, 0x16,
	0xd2, 0x7f, 0xe2, 0x6c, 0x58, 0x6c, 0xbe, 0x86, 0x68, 0x43, 0x3f, 0xc8, 0x72, 0xfd, 0x2c, 0xb9,
	0x7a, 0x16, 0x71, 0xc8, 0x46, 0x53, 0x6b, 0xd6, 0x5a, 0xee, 0x70, 0xe6, 0x4d, 0x8b, 0x3e, 0x95,
	0xec, 0x82, 0x64, 0xfb, 0x34, 0xbe, 0x83, 0xd1, 0xba, 0x71, 0x25, 0x45, 0x92, 0x1e, 0xf0, 0xe6,
	0x8a, 0x8c, 0xc5, 0x31, 0xd7, 0x9c, 0x5d, 0x92, 0xe5, 0x25, 0x36, 0xf3, 0x06, 0x92, 0xfb, 0x5a,
	0x48, 0x76, 0x55, 0xcc, 0xbb, 0x86, 0x76, 0x1f, 0xc0, 0xf5, 0x96, 0x5c, 0x65, 0x22, 0x55, 0xdc,
	0xee, 0x40, 0x6b, 0x91, 0x64, 0xfa, 0xc5, 0x7e, 0x80, 0x57, 0xee, 0xc6, 0x9b, 0x87, 0x48, 0xe9,
	0x8d, 0x02, 0xef, 0x76, 0x9c, 0xb6, 0xa6, 0xcd, 0xd9, 0xd9, 0xfc, 0xd2, 0xd9, 0x3b, 0x6c, 0xc7,
	0xf5, 0xb6, 0xed, 0xb7, 0xdf, 0xc3, 0xa0, 0xec, 0x46, 0x77, 0x75, 0xf0, 0x1e, 0x56, 0xcd, 0x7b,
	0xcc, 0x7f, 0x37, 0xa0, 0xe1, 0x2a, 0x5c, 0xc0, 0xf0, 0x93, 0x99, 0x96, 0x4a, 0x3d, 0xba, 0xbc,
	0xba, 0x2f, 0x8e, 0x5f, 0xd7, 0x8d, 0xb1, 0xd9, 0xec, 0x04, 0xbf, 0x6e, 0x0d, 0x61, 0x56, 0xc2,
	0xeb, 0x03, 0x3d, 0xed, 0x3e, 0xbe, 0x39, 0xec, 0x53, 0x67, 0x85, 0x7d, 0x82, 0x5f, 0x60, 0xf8,
	0x99, 0x0c, 0x2e, 0x05, 0x38, 0x39, 0x5e, 0x6c, 0x82, 0xf1, 0x91, 0x8f, 0xda, 0x27, 0xf8, 0x01,
	0x06, 0x8b, 0x30, 0xd2, 0x55, 0xab, 0xda, 0x25, 0x8f, 0xd6, 0x7f, 0xec, 0xff, 0x59, 0x4d, 0xac,
	0xbf, 0xab, 0x89, 0xf5, 0x6f, 0x35, 0xb1, 0x1e, 0xdb, 0xf4, 0xcb, 0xb9, 0xfb, 0x1f, 0x00, 0x00,
	0xff, 0xff, 0xbf, 0xf3, 0x05, 0xa1, 0x87, 0x04, 0x00, 0x00,
}
